#!/usr/bin/env python

import os
from collections import namedtuple

from src.generator import Generator
from src.selector import Selector
from src.options import get_simba_refactor_argument_parser, Args
from src.genome_resource import GenomeResource, Rank, Genome
from src.utils import mkdir_if_not_exists
from src.sample import Sample
from loguru import logger


# Parse args
parser = get_simba_refactor_argument_parser()
args = parser.parse_args()

# general
output_folder = os.path.abspath(getattr(args, Args.OUTPUT_FOLDER))
output_folder_scripts = os.path.abspath(getattr(args, Args.OUTPUT_FOLDER_SCRIPTS))

mkdir_if_not_exists(output_folder_scripts)

# within sample params
conspecific = getattr(args, Args.CONSPECIFIC)
species_number = getattr(args, Args.SPECIES_NUMBER)

# between sample params
sample_number = getattr(args, Args.SAMPLES)
shared_species_number_total = getattr(args, Args.SHARED_SPECIES_NUMBER_TOTAL)


min_cov = getattr(args, Args.MIN_VCOVERAGE)
max_cov = getattr(args, Args.MAX_VCOVERAGE)

# IO
gr = GenomeResource(getattr(args, Args.GENOME_MAP))

# Select
if not gr.has_x_of_rank(species_number, Rank.Species):
    print("Not enough species in the genome map")
    exit(9)

genomes_per_species = dict()

####################################################################
# Set Variables and Folders

samples_output_folder = os.path.join(output_folder, "samples")
profile_output_folder = os.path.join(output_folder, "gold_profiles")
meta_output_folder = os.path.join(output_folder, "meta_files")
roary_output_folder = os.path.join(output_folder, "roary_output")
tree_output_folder = os.path.join(output_folder, "trees")
sim_script_output_folder = os.path.join(output_folder_scripts, "read_simulation")
tree_script_output_folder = os.path.join(output_folder_scripts, "trees")
mkdir_if_not_exists(samples_output_folder)
mkdir_if_not_exists(profile_output_folder)
mkdir_if_not_exists(meta_output_folder)
mkdir_if_not_exists(roary_output_folder)
mkdir_if_not_exists(tree_output_folder)
mkdir_if_not_exists(sim_script_output_folder)
mkdir_if_not_exists(tree_script_output_folder)



def generate_sample(sample_name, sample_id, genome_resource, species_number, min_cov, max_cov, method="pareto"):
    selected_species = Selector.select_species(genome_resource, species_number, predicate=lambda x: not x.r_species.startswith('s__GUT'))
    selected_genomes = Selector.select_genomes_for_species(genome_resource, selected_species, select_conspecific=conspecific)

    id_to_genome = dict(zip([g.id for g in selected_genomes], selected_genomes))

    # Group genomes by species. make adjustable in the future
    genome_to_group = dict(zip([g.id for g in selected_genomes], [g.r_species for g in selected_genomes]))

    group_to_vcov = Generator.generate_vertical_coverage(genome_to_group, min_cov, max_cov, method=method)

    assert(min_cov == min(vcov for group, vcov in group_to_vcov.items()))
    assert(max_cov == max(vcov for group, vcov in group_to_vcov.items()))

    genome_to_vcov = Generator.resolve_group_vcov(genome_to_group, group_to_vcov)


    sample = Sample()
    sample.name = sample_name
    sample.id = sample_id
    sample.genomes = [id_to_genome[gid] for gid in genome_to_vcov.keys()]
    sample.vertical_coverages = genome_to_vcov.values()
    sample.setup()

    return sample


def generate_species_meta_dict(samples: list[Sample]):
    meta_dict = dict()

    rset = samples[0].rank_set(Rank.Species)

    MetaEntry = namedtuple("MetaEntry", "genome, coverage, sample")

    for sample in samples:
        for species, taxab in sample.rank_set(Rank.Species).items():
            # if len(taxab) != 1:
            #     print("Cannot currently do conspecific strains")
            #     print("Selection: {}".format(taxab))
            #     return dict()
            # genome, vcov = taxab[0]
            
            if species not in meta_dict:
                meta_dict[species] = []

            for genome, vcov in taxab:
                meta_dict[species].append(MetaEntry(genome, vcov, sample))

    return meta_dict


def generate_simulation_scripts_from_sample(sample: Sample, script_output_folder, data_output_folder):
    sim_script = "{}/{}.sh".format(script_output_folder, sample.name)
    sample_output_folder = "{}/{}".format(data_output_folder, sample.name)
    Generator.generate_scripts(sample_output_folder, sim_script, sample.genomes, sample.vertical_coverages, "sample{}".format(sample.id))


def generate_gold_standards_from_samples(sample: Sample, profile_output_folder):
    gold_standard_profile = "{}/gold_standard_{}.profile".format(profile_output_folder, sample.id)
    with open(gold_standard_profile, 'w') as output:
        Generator.write_profile(output, sample.genomes, sample.vertical_coverages)

def generate_gold_standards_conspecific_from_samples(sample: Sample, profile_output_folder):
    gold_standard_conspecific_profile = "{}/gold_standard_conspecific_{}.profile".format(profile_output_folder, sample.id)
    # for genome, vcov in zip(sample.genomes, sample.vertical_coverages):
    #     print("id: {} -> {}".format(genome.id, vcov))
    # input()
    with open(gold_standard_conspecific_profile, 'w') as output:
        Generator.write_conspecific_profile(output, sample.genomes, sample.vertical_coverages)


# Change every generator script to
# OUTPUT FOLDER
# OUTPUT_BASENAME
# FILE_EXTENSION

####################################################################
# generate samples

samples = [generate_sample("sample{}".format(sid), sid, gr, species_number, min_cov, max_cov)
           for sid in range(sample_number)]
meta_dict = generate_species_meta_dict(samples)

####################################################################
# Generate scripts

for sample in samples:
    generate_simulation_scripts_from_sample(sample, sim_script_output_folder, samples_output_folder)
    generate_gold_standards_from_samples(sample, profile_output_folder)
    generate_gold_standards_conspecific_from_samples(sample, profile_output_folder)

species_to_msa = Generator.generate_roary_scripts(output_folder, output_folder_scripts, meta_dict, batch_size=10)
Generator.generate_tree_scripts(tree_script_output_folder, tree_output_folder, output_folder + "/roary/", species_to_msa)
Generator.generate_meta_files(meta_output_folder, meta_dict)

all_genomes = list(set(genome for species, meta in meta_dict.items() for genome, vcov, sample in meta))
with open("{}/{}".format(output_folder_scripts, "gunzip.sh"), 'w') as out:
    out.write("#!/bin/bash\n\n")
    for genome in all_genomes:
        out.write("gunzip {}\n".format(genome.path))

with open("{}/{}".format(output_folder_scripts, "gzip.sh"), 'w') as out:
    out.write("#!/bin/bash\n\n")
    for genome in all_genomes:
        out.write("gzip {}\n".format(genome.unzipped_path()))


####################################################################
# Summary

print("Summary______________________")
print("Samples output:      {}".format(samples_output_folder))
print("Profiles output:     {}".format(profile_output_folder))
print("Meta output:         {}".format(meta_output_folder))
print("Roary output:        {}".format(roary_output_folder))
print("Tree output:         {}".format(tree_output_folder))
print("Simscript output:    {}".format(sim_script_output_folder))
